# MySql成长之路

### 1. 课程大纲
#### 1.学前准备
1. Mysql下载安装（MariaDB）
2. 熟悉MySQL工具（Navicat）和基本SQL操作
3. 熟悉主键、外键、飞空、唯一等约束
4. 熟悉索引、事务的概念和基本使用

#### 2.主要内容
1. MySql架构原理和存储机制
   ```
   MySQL体系结构（内存结构、磁盘结构）、SQL运行机制、存储引擎、Undo/Redo Log等
   ```
   
2. MySql索引存储机制和工作原理
   ```
   索引存储结构、索引查询原理、索引分析和优化、查询优化等
   ```

3. MySql事务和锁工作原理
   ```
   事务隔离级别、事务并发处理、锁机制和实战等
   ```

4. MySql集群架构及相关原理
   ```
   集群架构设计理念、主从架构、双主架构、分库分表等
   ```

5. 互联网海量数据处理实战
   ```
   ShardingSphere、MyCat中间件实战操作，分库分表实战
   ```

6. MySql第三方工具实战
   ```
   同步工具、运维工具、监控工具等
   ```

#### 3.MySQL应用架构变
1. 架构1.0 - 单机单库
   + 优点：
      1. 一个简单的小型网站或者应用背后的架构可以非常简单
   + 瓶颈：
      1. 数据量太大，超出一台服务器承受的范围
      2. 读写操作量太大，超出一台服务器承受的范围
      3. 可用性太低，服务器挂了服务也就挂了
      
2. 架构2.0 - 主从架构
   + 优点：
      1. 主库宕机可以通过主从切换保障高可用
      2. 主库抗写压力，从库分担读压力，提高读取并发能力
   + 瓶颈：
      1. 数据量太大，超出一台服务器承受的范围 
      2. 当写操作量太大，超出一台服务器承受的范围
      
3. 架构3.0 - 分库分表

4. 架构4.0 - 云数据库

### 2. MySQL架构原理
#### 1. MySQL体系架构
![MySQL架构图](MySQL架构图.png)
MySQL架构自顶向下大致可以分为：网络连接层、服务层、存储引擎层和系统文件层

1. 网络连接层
   ```
   客户端连机器（Client Connectors）：指能够与MySQL服务器建立连接的客户端。例如：C、Java、Python等
   ```
   
2. 服务层
   ```
   服务层是MySQL Server的核心，主要包含系统管理和控制工具、连接池、SQL接口、解析器、查询优化器和缓存6个部分   
   ```
   1. 连接池：负责存储和管理客户端与数据库的连接，一个线程负责管理一个连接。
   2. 系统管理和控制工具：例如备份恢复、安全管理、集群管理等。
   3. SQL接口：用于接受客户端发送的各种SQL命令，并且返回用户需要查询的结果。比如：DML、DDL、存储过程、视图、触发器等。
   4. 解析器：负责将请求的SQL解析生成一个“解析树”。然后根据一些MySQL规则进一步检查解析树是否合法。
   5. 查询优化器：当“解析树”通过解析器语法检查后，将交由优化器将其转化成执行计划，然后与存储引擎交互。
   6. 缓存：缓存机制是由一系列小缓存组成的。比如：表缓存、记录缓存、权限缓存，引擎缓存等。
      如果查询缓存中有命中的查询结果，查询语句就可以直接去查询缓存中取数据。

3. 存储引擎层   
   ```
   存储引擎负责MySQL中数据的存储和提取，与底层文件系统交互。MySQL存储引擎是插件式的，
   服务器中的查询执行引擎通过接口与存储引擎进行通信，接口屏蔽了不同存储引擎之间的差异。
   现在有很多种存储引擎，各有各的优点，最常见的是MyISAM和InnoDB。
   ```

4. 系统文件层
   ```
   该层负责将数据库的数据和日志存在文件系统之上，并完成与存储引擎的交互，是文件的物理存储层。
   主要包含日志文件、数据文件、配置文件、pid文件、socket文件等。
   ```
   + 日志文件：
      + 错误日志：
        ```
        记录错误日志，默认开启
        SHOW VARIABLES LIKE '%log_error%'
        ```
        
      + 通用查询日志:
        ```
        记录一般查询日志
        SHOW VARIABLES LIKE '%general%' 
        ```
        
      + 二进制日志
        ```
        记录了对MySQL数据库执行的更改操作，并且记录了语句的发生时间、执行时长；
        但是它不记录select、show等不修改数据的库的SQL。
        主要用于：主从复制、数据库恢复
        -- 是否开启
        SHOW VARIABLES LIKE '%bin_log%';
        -- 参数查看
        SHOW VARIABLES LIKE '%binlog%';
        -- 查看日志文件
        SHOW BINARY LOGS; 
        ```
      
      + 慢查询日志
        ```
        记录所有执行时间超时的查询SQL，默认10秒。
        -- 是否开启
        SHOW VARIABLES LIKE '%slow_query%';
        -- 超时时长
        SHOW VARIABLES LIKE '%long_query_time%';   
        ``` 
   + 配置文件
     ```
     用于存放MySQL所有的配置信息文件，比如：my.cnf、my.ini等
     ```
     
   + 数据文件
     ```
     1. db.opt文件：记录这个库默认使用的字符集和校验规则
     2. frm文件：存储与表相关的元数据信息，包括表结构的定义信息等，每张表都有一个frm文件
     3. MYD文件：MyISAM存储引擎专用，存放MyISAM表的数据，每张MyISAM引擎表都有一个对应的.MYD文件
     4. MYI文件：MyISAM存储引擎专用，存放MyISAM表的索引相关信息，每张MyISAM引擎表都有一个对应的.MYI文件
     5. ibd文件和IBDATA：存放InnoDB的数据文件（包括索引）。InnoDB存储引擎有两种表空间方式：独享表空间和共享表空间。
        独享表空间使用.ibd来存放数据，每张InnoDB引擎表都有一个对应的.ibd文件。
        共享表空间使用.IBDATA来存放数据，所有InnoDB引擎表共同使用一个（或多个、自行配置）.IBDATA文件
     6. ibdata1文件：系统表空间数据文件，存储表元数据、Undo日志等。
     7. ib_logfile0、ib_logfile1文件：Redo日志文件
     8. pid文件：pid文件是mysqld应用程序在Unix/Linux环境下的一个进程文件，和许多其他的Unix/Linux服务端程序一样，它存放着自己的进程id。
     9. socket文件：socket文件是在Unix/Linux环境下才有的，用户在Unix/Linux环境下客户端连接可以不通过TCP/IP网络而直接使用Unix Socket来连接MySQL。    
     ```
   
#### 3.MySQL日志系统原理
#### 3.5.1 Undo Log介绍
```
Undo：意为撤销或取消，以撤销操作为目的，返回指定某个状态的操作。

Undo Log：数据库事务开始之前，会将要修改的记录存放到Undo日志里，当事务回滚时或者数据库奔溃时，可以利用Undo日志，撤销未提交的事务对数据库产生的影响

Undo Log产生和销毁：Undo Log在事务开始前产生；事务在提交时，并不会立刻删除Undo log，InnoDB会将该事务对应的Undo Log放入到删除列表中，
    后台会通过后台线程purge thread进行回收处理。Undo Log属于逻辑日志，记录一个变化过程。

Undo Log存储：Undo Log采用段的方式管理和记录。在InnoDB数据文件中包含一种Rollback segment回滚段，内部包含1024个Undo Log segment。
    SHOW VARIABLES LIKE '%innodb_undo%'
```
#### 3.5.2 Undo Log作用
```
1. 实现事务的原子性
2. 实现多版本并发控制（MVCC）
```

#### 3.6 Redo Log和Binlog
1. Redo Log日志
   1. Redo Log介绍
      ```
      Redo：顾名思义就是重做。以恢复操作为目的，在数据库发生意外时重现操作。
      
      Redo Log：指事务中修改的任何数据，将最新的数据备份存储的位置（Redo Log），被称为重做日志。
      
      Redo Log的生成和释放：随着事务操作的执行，就会生成Redo Log，在事务提交时会将产生的Redo Log写入到Log Buffer，
          并不是随着事务的提交就立刻写入磁盘文件。等事务操作的脏页写入到磁盘之后，Redo Log占用的空间就可以重用了（被覆盖写入）
      ```
  
   2. BinLog
    
### 第二部分 MySQL索引原理 
#### 第一节 索引类型
索引可以提升查询速度，会影响where查询，以及order by排序。MySQL索引类型如下：
+ 索引存储结构划分：B Tree索引、Hash索引、FULLTEXT全文索引、R Tree索引
+ 应用层次划分：普通索引、唯一索引、主键索引、复合索引
+ 索引键值类型划分：主键索引、辅助索引（二级索引）
+ 数据存储和索引键值逻辑关系划分：聚集索引（聚簇索引）、非聚集索引（非聚簇索引）
   
#### 1.1 普通索引
最基本的索引类型，基于普通字段建立的索引，没有任何限制。创建方式如下：
1. CREATE INDEX index_name ON table_name(column_name)
2. ALTER TABLE table_name ADD INDEX index_name(column)
3. CREATE TABLE table_name([...],INDEX index_name(column_name))

#### 1.2 唯一索引
与普通索引类似，不同的就是：索引字段的值必须唯一，但允许为空值。创建方式如下：
1. CREATE UNIQUE INDEX index_name ON table_name(column_name)
2. ALTER TABLE table_name ADD UNIQUE INDEX index_name(column)
3. CREATE TABLE table_name([...],UNIQUE index_name(column_name))

#### 1.3 主键索引
主键索引是一种特殊的唯一索引，不允许有空值，每个表的主键只能有一个。创建方式如下：
1. ALTER TABLE table_name ADD PRIMARY KEY index_name(column)
2. CREATE TABLE table_name([...],PRIMARY KEY index_name(column_name))
   
#### 1.4 复合索引
在多个列上创建的索引，就是复合索引。复合索引在数据库操作期间所需要的开销更小，
可以代替多个单一索引。

索引同时有两个概念叫做窄索引和宽索引，窄索引是指列为1-2列的索引，宽索引是指2列以上的索引
索引设计的重要原则是：能用窄索引就不用宽索引
   
#### 1.5 全文索引
1. CREATE FULLTEXT INDEX index_name ON table_name(column)
2. ALTER TABLE table_name ADD FULLTEXT INDEX index_name(column)
3. CREATE TABLE table_name([...],FULLTEXT KEY index_name(column)

+ 全文索引必须在字符串、文本字段上建立。
+ 全文索引字段值必须在最小字符和最大字符之间才会有效。（INNODB：3~84，MyISAM：4~84）
+ 全文索引字段值要进行切词处理，按照syntax字符进行切割。
+ 全文索引匹配查询，默认使用的是等值匹配。例如：a只会匹配a，不会匹配ab；如果想匹配可以在bool模式下搜索a*

#### 第二节 索引类型
索引的定义：索引是存储引擎用于快速查找记录的一种数据结构。需要额外开辟空间和数据维护工作。
+ 索引是物理数据页存储，在数据文件中（InnoDB，.idb文件），利用数据页（page）存储。
+ 索引可以加快检索速度，但是同时也会降低增删改操作速度，索引维护需要代价

索引设计的理论知识：二分查找法、Hash和B+Tree。
#### 2.1 二分查找法
#### 2.2 Hash索引
#### 2.3 B+Tree结构
Mysql数据库索引采用的是B+Tree结构，在B-Tree结构上做了优化改造。

+ B-Tree结构：
    + 索引值和data数据分布在整棵树结构中
    + 每个节点可以存放多个索引值及对应的data数据
    + 树节点中的多个索引值从左到右升序排列
    
B-Tree的搜索：
```
从根节点开始，对节点内的索引值序列采用二分法查找，如果命中就结束查找。
没有命中会进入子节点重复查找过程，直到所对应的节点指针为空，或已经是叶子节点了才结束
```

+ B+Tree结构：
    + 非叶子节点只存储索引值，不存储data数据，这样便于存储更多的索引值
    + 叶子节点包含了所有的索引值和data数据
    + 叶子节点之间用指针连接，提高区间的访问性能

B+Tree的搜索：
```
相比B树，B+树进行范围查找时，只需要查找定位两个节点的索引值，然后利用叶子节点的指针进行遍历即可。
```

#### 2.4 聚簇索引和辅助索引
+ 聚簇索引：
   ```
   聚簇索引是一种数据存储方式，InnoDB的聚簇索引就是按照主键顺序构建B+Tree结构。
   B+Tree的叶子节点就是行记录，行记录和主键值紧凑地存储在一起，这也意味着InnoDB的主键索引就是数据表本身，
   它按主键顺序存放了整张表的数据，占用的空间就是整个表数据量的大小。通常说主键索引就是聚簇索引
   ```

+ 辅助索引：
   ```
   InnoDB辅助索引，也叫作二级索引，是根据索引列结构B+Tree结构。但在B+Tree的叶子结点中只存了索引列
   和主键的信息。二级索引占用的空间会比聚簇索引小很多，通常创建辅助索引就是为了提升查询效率。
   一个表InnoDB只能创建一个聚簇索引，但可以创建多个辅助索引。 
   ```

InnoDB的表要求必须有聚簇索引：
1. 如果表定义了主键，则主键索引就是聚簇索引
2. 如果表没有定义主键，则第一个非空unique列作为聚簇索引
3. 否则InnoDB会创建一个隐藏的row-id作为聚簇索引 
   
聚簇索引和非聚簇索引：B+Tree叶子节点存放主键索引和行记录就是聚簇索引；如果索引值和行记录分开存放就属于非聚簇索引。
主键索引和辅助索引：B+Tree的叶子节点存放的是主键字段值就属于主键索引；如果存放的是非主键值就属于辅助索引（二级索引）。

#### 第三节 索引分析与优化   
#### 3.1 EXPLAIN   
```
EXPLAIN 可以对SELECT语句进行分析，并输出SELECT执行的详细信息，供开发人员针对性的优化。
```
+ select_type: 表示查询的类型。
  + SIMPLE：表示查询语句不包含子查询、UNION等操作
  + PRIMARY：表示查询是最外层的
  + UNION：表示查询是UNION联合的
  + DEPENDENT UNION：表示UNION查询中使用到了外面的查询结果
  + UNION RESULT：UNION的结果
  + SUBQUERY：子查询
  + DEPENDENT SUBQUERY：表示子查询使用到了外面的查询结果
 
+ type：表示存储引擎查询数据时采用的方式。比较重要的一个属性，通过它可以判断是否为全表扫描。
  常用属性从上到下依次增强
  + ALL：表示全表扫描，性能最差 
  + index：表示基于索引的全表扫描，先扫描索引再扫描全表数据。排序场景性能比ALL高
  + range：表示使用索引范围查询。
  + ref：表示使用非唯一索引进行单值查询。
  + eq_ref：一般情况下出现在多表join查询中。表示前面表的每一行记录，都只能匹配后面表的一行结果。
  + const：表示使用主键或唯一索引做等值查询，也称作：常量查询。
  + NULL：表示不用访问表，速度最快。
    
+ possible_keys：表示查询时能够使用到的索引，并不一定会真正使用，显示的是索引名称。
+ key: 表示查询时真正使用的索引，显示的是索引名称。
+ row：查询优化器根据统计信息，估算SQL要查询到结果扫描多少数据。rows越小越好
+ key_len：表示查询使用了索引的字节数量。可以判断是否使用了组合索引或只用到了索引的最左部分的部分字段。
   ```
   key_len的计算规则如下：
      字符串类型：
         1. 字符串长度跟字符集有关：latin1=1、gbk=2、utf8=3、utfmb4=4
         2. char(n)：n * 字符集长度
         3. varchar(n)：n * 字符集长度 + 2字节
   
      数值类型：
         1. TINYINT：1个字节
         2. SAMLLINT：2个字节
         3. MEDIUMIT：3个字节
         4. INT、FLOAT：4个字节
         5. BIGINT、DOUBLE：8个字节
  
     时间类型：
         1. DATE：3个字节
         2. TIMESTAMP：4个字节
         3. DATETIME：8个字节
   
     字段属性：  
         NULL属性占用1个字节，如果一个字段设置了NOT NULL，则没有此项
   ```
+ Extra：表示很多额外的信息，各种操作会在Extra提示相关信息，常见几种如下：
   + Using where：表示查询需要通过索引回表查询数据。
   + Using index：表示查询通过索引就可以满足所需数据。
   + Using filesort：表示查询出来的结果需要额外的排序。数据量小在内存中做，数据量大在磁盘做，因此有Using filesort建议优化
   + Using temprorary：表示查询使用到了临时表，一般出现于去重、分组操作，建议优化
    
#### 3.2 回表查询  
先通过辅助索引定位主键值，然后再通过聚簇索引定位行记录，这就是回表查询

#### 3.3 索引覆盖
只要在一颗索引树上就能获取SQL所需的所有列数据，无需回表，速度更快，这就是索引覆盖 

#### 3.4 最左前缀原则
复合索引使用时遵循最左前缀原则，即查询中使用到最左边的列，那么查询就会使用索引，
如果从索引的第二列开始查找，那么索引将失效。

#### 3.5 LIKE查询
在使用like查询时，索引可以被使用，但是字符串前面不得有%

#### 3.6 NULL查询
可以使用索引但是不建议使用，通常列设置为NOT NULL   

#### 3.7 索引与排序
MySQL查询支持filesort和index两种方式的排序，filesort是先把结果查出来，然后在缓存或磁盘进行排序操作，效率较低。
index是利用索引自动实现排序，不需要另外排序操作，效率会表较高。

filesort有两种排序方式：
+ 双路排序：需要两次磁盘扫描读取，最终得到用户数据。第一次将排序字段读取出来，然后排序。第二次去读取其他字段数据。
+ 单路排序：从磁盘查询所需的所有数据，然后在内存排序将结果返回。如果排序数据超出了sort_buffer，会导致多次磁盘读取操作
  并创建临时表，最后产生多次IO，反而会增加负担。解决方案增大sort_buffer_size和max_length_for_sort_data，少使用select *
   

+ 使用index排序的规则：
   + ORDER BY语句满足索引最左原则
   + WHERE + ORDER BY语句满足索引最左原则
    
+ 使用filesort排序的规则：
   + ORDER BY语句不满足索引最左原则
   + WHERE + ORDER BY语句不满足索引最左原则
   + 对索引列同时使用了asc和desc
   + WHERE + ORDER BY语句满足索引最左原则，但WHERE语句使用了范围查询
   + ORDER BY使用了两个及两个以上的字段，但创建的索引不能覆盖所有字段
   + WHERE与ORDER BY使用了不同的索引
   + WHERE或ORDER BY使用了函数表达式或进行了其他计算

#### 第四节 查询优化
#### 4.2 慢查询优化
+ 避免全表扫描：EXPLAIN分析type属性为ALL
+ 避免全索引扫描：EXPLAIN分析type属性为index
+ 索引过滤性不好：靠索引字段选型、数据量和状态、表设计、虚拟字段等优化
+ 避免频繁的回表扫描查询：尽量少用SELECT *，使用索引覆盖

#### 4.3 分页查询优化
+ 利用索引覆盖优化
+ 利用子查询优化

### 第三部分 MySQL事务和锁
#### 第一节 ACID特性
#### 1.1 原子性（Atomicity）
事务是一个原子操作单元，其对数据的修改，要么全部执行，要么全部不执行

#### 1.2 一致性（Consistency）
事务开始之前和事务结束之后，数据库的完整性限制未被破坏。
一致性分为两方面：约束一致性和数据一致性
+ 约束一致性：创建表结构时所指定的外键、Check、唯一索引等约束，MySQL中不支持Check
+ 数据一致性：一个综合性的规定，由原子性、持久性、隔离性共同保证的结果，而不是单单依赖于某一种技术。

#### 1.3 隔离性（Isolation）
一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对其他的并发事务是隔离的

#### 1.4 持久性（Durability）
一个事务一旦提交，它对数据库中数据的改变就应该是永久性的，后续的操作或故障不应该对其有任何影响，不会丢失

#### 第二节 事务控制的演进过程
#### 2.1 并发事务
+ 更新丢失
+ 脏读
+ 不可重复读
+ 虚读/幻读

#### 2.2 排队
#### 2.3 排他锁
#### 2.4 MVCC
```
多版本控制MVCC，就是Copy on Write的思想。实现了读读并行、读写并行、写读并行，写写不并行
MVCC是在只在Read Committed和Repeatable Read两种隔离级别下工作
```
MCVV读操作：
+ 快照读：读取的记录是快照版本（有可能是历史版本），不用加锁
+ 当前读：读取的记录是最新版本，并且当前读返回的记录，都会加锁，保证其他事务不会再并发修改这条记录

#### 第三节 事务的隔离级别
#### 3.1 隔离级别类型
+ 读未提交（Read Uncommitted）: 读操作不加读锁
+ 读已提交（Read Committed）：读操作添加读锁，读取完成后立即释放读锁
+ 可重复读（Repeatable Read）：读操作添加读锁，直到事务结束才释放读锁
+ 串行化（Serializable）：添加一个表锁，直到事务结束才释放

事务隔离级别和锁的关系：隔离级别是SQL92定制的标准，锁是隔离级别的实现

#### 第四节 锁机制和实战
#### 4.1 锁分类
+ 从操作粒度划分：
  + 表级锁：MyISAM、InnoDB、DBD
  + 行级锁：InnoDB
  + 页级锁：BDB

+ 从操作类型划分：
  + 读锁：也叫S锁、共享锁
  + 写锁：也叫X锁、排他锁


+ 从操作的性能划分：
  + 乐观锁
  + 悲观锁  

### 第四部分 MySQL集群架构
#### 第一节 集群架构设计
#### 1.1 架构设计理念
在集群架构设计时，蛀牙遵从下面三个维度：
+ 可用性
+ 扩展性
+ 一致性

#### 1.2 可用性设计
+ 站点高可用，冗余站点
+ 服务高可用，冗余服务
+ 数据高可用，冗余数据

高可用的实质就是冗余。但是冗余数据会带来数据一致性问题

实现高可用的方案有以下几种架构模式：
+ 主从模式：简单灵活，能满足多种需求。比较主流的用法，但是写操作高可用需要自行处理。
+ 双主模式：互为主从，有双主双写、双主单写两种方式。建议使用双主单写

#### 1.3 扩展性设计
读操作性扩展：
+ 加从库：简单易操作，方案成熟。从库过多会影响主库性能损耗
+ 分库分表：可以分为垂直拆分和水平拆分，垂直拆分可以环境部分压力，水平拆分理论上可以无限扩展

写操作性扩展：
+ 分库分表

#### 1.4 一致性设计
一致性设计主要考虑集群中各数据库数据同步以及同步延迟问题，可以采用的方案如下：
+ 不使用从库：扩展读性能需要单独考虑，否则容易出现系统瓶颈。
+ 增加访问路由层：可以先统计主从数据同步最长的时间t，在该时间内先访问主，之后再访问从

#### 第二节 主从模式
#### 2.1 适用场景
MySQL主从复制用途：
+ 实时灾备，用户故障且切换（高可用）
+ 读写分离，提供查询服务（读扩展）
+ 数据备份，避免影响业务（高可用）

主从部署必要条件：
+ 从数据库服务器能连通主库
+ 主库开启binlog日志
+ 主从server-id不同

#### 第三节 双主模式

#### 第四节 分库分表
分库分表方案：只分库、只分表、分库又分表
水平拆分：

#### 4.1 拆分方式
+ 垂直拆分：由于表多导致的单个库大。将表拆分到多个库中，解决表过多或字段过多的问题
  + 优点：
      + 拆分后业务清洗，拆分规则明确
      + 易于数据的维护和扩展
      + 可以使得行数据变小，一个数据块（Block）就能存放更多的数据，在查询时就会减少I/O次数
      + 可以达到最大化利用Cache的目的，具体在垂直拆分的时候可以将不长变的字段放一起，将经常变的放一起
      + 便于实现冷热分离的数据表设计模式。
  + 缺点：
      + 主键出现冗余，需要管理冗余列
      + 会引起表连接JOIN操作，可以通过在业务服务器上进行join来减少数据库压力，提高了系统的复杂度
      + 依然存在单表数据量多大的问题
      + 事务处理复杂
    

+ 水平拆分：由于表记录多导致的单个库大。将表记录拆分到多个表中，解决表中记录过多问题
    + 优点：
        + 拆分规则设计好，join操作可以使用数据库
        + 不存在单库数据量大，高并发的性能瓶颈
        + 切分的表结构相同，应用层改造较少，只需要增加路由规则即可；
        + 提高了系统的稳定性和负载能力
        + 便于实现冷热分离的数据表设计模式。
    + 缺点：
        + 拆分规则难以抽象
        + 跨库join性能较差
        + 分片事务的一致性难以解决
        + 数据扩容的难度和维护量极大

#### 4.2 主键生成策略
+ UUID
+ COMB
+ SNOWFLAKE
+ 数据库ID表
+ Redis生成ID

#### 4.3 分片策略
##### 4.3.1 概念
分片（sharding）就是用来确定数据在多台存储设备上分布的技术。
将一个数据库打碎成多个的过程就叫做分片，分片是属于横向扩展的方案。

分片：表示分配过程，是一个逻辑上的概念，表示如何实现
分库分表：表示分配结果，是一个物理上的概念，表示最终的实现

数据库扩展方案：
+ 横向扩展：一个库变多个库，加机器
+ 纵向扩展：一个库还是一个库，加CPU或提存，优化机器性能

##### 4.3.2 分片策略
+ 基于范围分片
  + 优点：新的数据可以落在新的存储节点上，如果集群扩容，数据无需迁移。
  + 缺点：数据热点不均匀，数据冷热不均匀，导致节点负荷不均匀。
    
+ 哈希取模分片
  + 优点：实现简单，数据分配比较均匀，不容易出现冷热不均匀，符合不均匀的情况
  + 缺点：扩容时会产生大量的数据迁移
    
+ 一致性哈希分片

#### 4.4 扩容方案
+ 停机扩容
+ 平滑扩容

### 扩展：MySQL性能优化
数据库优化维度：
  + 硬件升级
  + 系统配置
  + 表结构设计
  + SQL语句及索引

优化选择：
  + 优化成本：硬件升级 > 系统配置 > 表结构设计 > SQL语句及索引
  + 优化效果：硬件升级 < 系统配置 < 表结构设计 < SQL语句及索引

#### 1. 系统配置调优
##### 1.1 保证从内存中读取数据 
1. 调大：innodb_buffer_pool_size，使用该命令查看内存使用情况：SHOW GLOBAL STATUS LIKE 'innodb_buffer_pool_page_%'
2. 禁用SWAP，只能针对专门用于某个特定服务的服务器使用

##### 1.2 数据预热
启动之后查询一次可能用到的热点数据

##### 1.3 降低磁盘写入次数
1. 增大redilog，减少落盘次数，设置：innodb_log_file_size为innodb_buffer_pool_size的1/4
2. 通用查询日志不开，慢查询日志遇到性能问题再开，bin-log开

##### 1.4 提高磁盘读写性能
使用SSD或内存磁盘

#### 2. 表结构设计优化
##### 2.1 设计中间表
设计中间表，一般针对于统计分析功能，或者实时性不高的需求

##### 2.2 设计冗余字段
为了减少关联查询，创建合理的冗余字段（使用冗余字段时还需要注意数据一致性问题）

##### 2.3 拆表
##### 2.4 主键优化
##### 2.5 字段优化
1. NOT NULL避免数据库NULL值比较
2. 字段尽量短
3. 能用数字代替的就不要用字符串

#### 3. SQL语句及索引优化
##### 3.1 EXPLAIN查看索引使用情况
##### 3.2 SQL语句中IN包含的值不宜过多
Mysql对IN做了优化，将IN中的常量全部存到数组中并排序，如果IN中的值较多，产生的消耗也比较大
##### 3.3 SELECT语句务必指明字段名称
SELECT *增加了很多不必要的消耗（CPU、内存、IO带宽、网络带宽），减小了覆盖索引使用的概率，增加了回表扫描的概率
##### 3.4 查询少量数据时使用LIMIT
##### 3.5 排序字段加索引
##### 3.6 限制条件中没有索引，少用OR
##### 3.7 尽量用union all代替union
##### 3.8 不使用ORDER BY RAND()
##### 3.9 区分IN和EXISTS、NOT IN和NOT EXISTS
+ IN：适合外大内小
+ EXISTS：适合外小内大
##### 3.10 使用合理的分页方式，提高分页查询效率
##### 3.11 分段查询
##### 3.12 不使用%前缀查询
##### 3.13 避免在where子句上使用表达式或计算逻辑
##### 3.14 避免隐式类型转换
##### 3.15 对于联合索引要遵循最左原则
##### 3.16 必要时使用force index来强制使用某个索引
##### 3.17 注意范围查询语句
##### 3.18 使用join优化






